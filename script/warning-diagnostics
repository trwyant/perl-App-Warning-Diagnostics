#!/usr/bin/env perl

use 5.010;

use strict;
use warnings;

use App::Warning::Diagnostics
    qw{ builtins pod_encoding warning_diagnostics };
use Config;
use Getopt::Long 2.33 qw{ :config auto_version };
use Pod::Text;
use Pod::Usage;

our $VERSION = '0.000_009';

my %opt = (
    pager	=> -t STDOUT,
    render	=> 1,
);

my @lgl_opt = qw{ complete|completion=s pager! render! };

GetOptions( \%opt,
    @lgl_opt,
    help => sub { pod2usage( { -verbose => 2 } ) },
) or pod2usage( { -verbose => 0 } );

if ( $opt{complete} ) {
    my $code = __PACKAGE__->can( "complete_$opt{complete}" )
	or die "Completion style '$opt{complete}' not defined\n";
    $code->( @lgl_opt, qw{ help version } );
    exit;
}

defined( my $raw_pod = warning_diagnostics( @ARGV ) )
    or die "No warning categories specified\n";

my $out;
if ( $opt{pager} ) {
    my $pager = $ENV{PAGER} || $Config{pager};
    open $out, '|-', $pager	## no critic (RequireBriefOpen)
	or warn "Failed to open pipe to $pager: $!\n";
}

$out //= \*STDOUT;

if ( defined( my $enc = pod_encoding() ) ) {
    binmode $out, ":encoding($enc)"
	or die "Unable to specify encoding $enc for output: $!\n";
}

if ( $opt{render} ) {
    my $psr = Pod::Text->new();
    open my $fh, '<', \$raw_pod
	or die "Failed to open SCALAR reference: $!\n";
    $psr->parse_from_file( $fh, $out );
    close $fh;
} else {
    print { $out } $raw_pod;
}

# NOTE that the default bash variable COMP_WORDBREAKS contains a colon
# (':'), but I don't like the way this behaves.
use constant COMP_WORDBREAKS	=> qr/ ( \s+ | ["'\@><=;|&(] ) /smx;	# )

sub complete_bash {
    my @option = @_;
    my @rslt = complete_zsh_bash( @option );

    s/ .* :: (?= . ) //smx for @rslt;

    {
	my %uniq;
	@rslt = grep { ! $uniq{$_}++ } @rslt;
    }

    say for @rslt;
    return;
}

sub complete_zsh_bash {
    my @option = @_;

    my $line = $ENV{COMP_LINE};
    my $point = $ENV{COMP_POINT} // length $line;

    my @words = split COMP_WORDBREAKS, substr $line, 0, $point;
    $line =~ m/ @{[ COMP_WORDBREAKS ]} \z /smx
	and push @words, '';

    @words
	or return;

    my @rslt;

    my $complete = $words[-1];

    # NOTE to the curious: I believe nothing below this point is
    # specific to bash. If there is need for a readline_completion() the
    # below code could be factored into a separate subroutine to be
    # called by bash_completion(), readline_completion(), or potentially
    # any other completion code.
    # NOTE except that zsh's bash completion emulation works differently
    # than actual bash completion.

    if ( $complete =~ m/ \A --? /smx ) {

	push @rslt, _complete_options( $complete, @option );

    } else {

	$complete =~ m/ \w : \z /smx
	    and $complete .= ':';
	my $re = qr/ \A ( \Q$complete\E [\w-]* (?: :: )? ) /smx;
	my %found;
	foreach my $cat ( builtins() ) {
	    foreach my $item ( $cat, "no-$cat" ) {
		$item =~ m/ $re /smx
		    or next;
		$found{$1}++
		    and next;
		push @rslt, "$1";
	    }
	}

	'' eq $complete
	    and push @rslt, _complete_options( $complete, @option );

    }

    @rslt = sort @rslt;

    defined wantarray
	and return @rslt;

    say for @rslt;

    return;
}

sub _complete_options {
    my ( $complete, @option ) = @_;

    my $prefix = '--';

    my @rslt;

    foreach my $o ( @option ) {
	my ( $names, $kind ) = split qr< ( [:=!] ) >smx, $o;
	$kind //= '';
	my @opts = split qr< [|] >smx, $names;
	if ( '!' eq $kind ) {
	    push @rslt, grep { ! index $_, $complete }
		map {; ( "$prefix$_", "${prefix}no-$_" ) }
		@opts;
	} else {
	    push @rslt, grep { ! index $_, $complete }
		map { "$prefix$_" } @opts;
	}
    }

    return @rslt;
}

__END__

=head1 TITLE

warning-diagnostics - List diagnostics enabled by specified warning categories

=head1 SYNOPSIS

 warning-diagnostics uninitialized
 warning-diagnostics io no-unopened no-closed
 warning-diagnostics --help
 warning-diagnostics --version

=head1 OPTIONS

=head2 --complete

 --complete bash
 --complete zsh_bash

This option specifies that command completion be done in the specified
style. The script then exits. Valid styles are:

=over

=item bash

Bash completion

=item zsh_bash

Zsh emulation of Bash completion.

=back

For completion under Bash specify

 complete \
   -C 'warning-diagnostics --complete bash' \
   warning-diagnostics

in F<~/.bashrc>. For completion under zsh Bash completion emulation
specify

 complete \
   -C 'warning-diagnostics --complete zsh_bash' \
   warning-diagnostics

in F<~/.zshrc>.

=head2 --completion

This is just an alias for L<--complete|/--complete>.

=head2 --help

This option displays the documentation for this script. The script then
exits.

=head2 --pager

If this Boolean option is asserted, the output is routed to a pager,
either the pager specified by environment variable C<PAGER>, or to the
pager specified in configuration variable C<pager> if the environment
variable is not defined.

The default is C<--pager> if C<STDOUT> is a terminal; otherwise it is
C<--no-pager>.

=head2 --render

If this Boolean option is asserted the POD is rendered using
L<Pod::Text|Pod::Text>. Otherwise the raw POD is output.

The default is C<--render>, but you can disable this by specifying
C<--no-render>.

=head2 --version

This option displays the version of this script. The script then exits.

=head1 DETAILS

This Perl script displays the diagnostics that are enabled by enabling
the warnings specified on the command line. More than one warning
category can be specified, and categories can be negated by prefixing
C<'no'> or C<'no-'> to their names. Categories are combined in
left-to-right order, so specifying arguments

 io noclosed no-unopened

specifies the diagnostics possible under

 no warnings;
 use warnings qw{ io };
 no warnings qw{ closed unopened };

=head1 AUTHOR

Thomas R. Wyant, III F<wyant at cpan dot org>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2021 by Thomas R. Wyant, III

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl 5.10.0. For more details, see the full text
of the licenses in the directory LICENSES.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut

# ex: set textwidth=72 :
